# JS中的栈内存和堆内存

## 引言
JS的内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 
其中栈存放变量，堆存放复杂对象，池存放常量，所以也叫常量池。

## 栈数据结构

## 堆数据结构

## 变量类型与内存的关系

**基本数据类型共有6种：**
1. Sting
2. Number
3. Boolean
4. null
5. undefined
6. Symbol

**引用数据类型**

Array,Function,Object...可以认为除了上文提到的基本数据类型以外，所有类型都是引用数据类型。



### 栈内存和堆内存的优缺点

### 栈内存和堆内存的垃圾回收



栈是一种特殊的列表，栈内的元素只能通过列表的一端访问，这一端称为栈顶。咖啡厅内的一摞盘子是现实世界中常见的栈的例子。只能从最上面取盘子，盘子洗净后，也只能摞

在这一摞盘子的最上面。栈被称为一种后入先出（LIFO，last-in-ﬁrst-out）的数据结构。

由于栈具有后入先出的特点，所以任何不在栈顶的元素都无法访问。为了得到栈底的元 素，必须先拿掉上面的元素


对栈的两种主要操作是将一个元素压入栈和将一个元素弹出栈。入栈使用push()方法，出栈使用pop()方法。图4-1演示了入栈和出栈的过程。

另一个常用的操作是预览栈顶的元素。pop()方法虽然可以访问栈顶的元素，但是调用该方法后，栈顶元素也从栈中被永久性地删除了。peek()方法则只返回栈顶元素，而不删除它。




```javascript
var a = {n: 1};
var b = a;
a.x = a = {n: 2};


a.x 	// --> undefined
b.x 	// --> {n: 2}
```

答案已经写上面了，这道题的关键在于

1、优先级。.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。
2、赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}






给一个全局变量赋值为null，相当于将这个变量的指针对象以及值清空，如果是给对象的属性 赋值为null，或者局部变量赋值为null,相当于给这个属性分配了一块空的内存，然后值为null， JS会回收全局变量为null的对象。

给一个全局变量赋值为undefined，相当于将这个对象的值清空，但是这个对象依旧存在,如果是给对象的属性赋值 为undefined，说明这个值为空值


栈：原始数据类型（Undefined，Null，Boolean，Number、String）
堆：引用数据类型（对象、数组和函数）

两种类型的区别是：存储位置不同；
原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体




https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966

const 的存储位置，引用类型为什么可以修改

null 是在栈内存中，还是堆内存中

typeof null 为什么是 object


https://github.com/yygmind/blog/issues/14

https://github.com/yygmind/blog/issues/15

https://www.jianshu.com/p/996671d4dcc4

https://blog.csdn.net/xdd19910505/article/details/41900693







